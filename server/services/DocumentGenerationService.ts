/**
 * DOCUMENT GENERATION SERVICE
 *
 * Generates real, downloadable business documents from collaboration outputs
 */

import PDFDocument from 'pdfkit';
import { Writable } from 'stream';

export interface DocumentSection {
  title: string;
  content: string;
  author?: string;
}

export interface GenerateDocumentOptions {
  title: string;
  subtitle?: string;
  sections: DocumentSection[];
  metadata?: {
    createdBy?: string;
    collaborationId?: string;
    date?: Date;
  };
}

/**
 * Generate PDF Business Document
 */
export async function generatePDFDocument(
  options: GenerateDocumentOptions
): Promise<Buffer> {
  return new Promise((resolve, reject) => {
    const chunks: Buffer[] = [];
    const doc = new PDFDocument({
      size: 'A4',
      margins: {
        top: 50,
        bottom: 50,
        left: 50,
        right: 50
      }
    });

    // Collect PDF chunks
    doc.on('data', (chunk) => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Title Page
    doc.fontSize(24)
       .font('Helvetica-Bold')
       .text(options.title, { align: 'center' });

    if (options.subtitle) {
      doc.fontSize(14)
         .font('Helvetica')
         .moveDown(0.5)
         .text(options.subtitle, { align: 'center' });
    }

    // Metadata
    doc.moveDown(2);
    doc.fontSize(10)
       .font('Helvetica')
       .text(`Generated: ${new Date().toLocaleDateString()}`, { align: 'center' });

    if (options.metadata?.createdBy) {
      doc.text(`Created by: ${options.metadata.createdBy}`, { align: 'center' });
    }

    doc.text('Powered by SINTRA AI Multi-Agent System', { align: 'center' });

    // Sections
    doc.moveDown(3);

    options.sections.forEach((section, index) => {
      // Section Title
      doc.fontSize(16)
         .font('Helvetica-Bold')
         .text(section.title);

      if (section.author) {
        doc.fontSize(10)
           .font('Helvetica-Oblique')
           .text(`By: ${section.author}`);
      }

      // Section Content
      doc.moveDown(0.5);
      doc.fontSize(11)
         .font('Helvetica')
         .text(section.content, {
           align: 'justify',
           lineGap: 2
         });

      // Add spacing between sections
      if (index < options.sections.length - 1) {
        doc.moveDown(2);
        doc.moveTo(50, doc.y)
           .lineTo(doc.page.width - 50, doc.y)
           .stroke('#cccccc');
        doc.moveDown(1.5);
      }
    });

    // Footer on last page
    doc.moveDown(3);
    doc.fontSize(8)
       .font('Helvetica-Oblique')
       .text('This document was generated by SINTRA AI Multi-Agent Collaboration System', {
         align: 'center'
       });

    if (options.metadata?.collaborationId) {
      doc.text(`Collaboration ID: ${options.metadata.collaborationId}`, {
        align: 'center'
      });
    }

    doc.end();
  });
}

/**
 * Generate Markdown Document
 */
export function generateMarkdownDocument(options: GenerateDocumentOptions): string {
  let markdown = `# ${options.title}\n\n`;

  if (options.subtitle) {
    markdown += `**${options.subtitle}**\n\n`;
  }

  // Metadata
  markdown += `---\n`;
  markdown += `Generated: ${new Date().toLocaleDateString()}\n`;
  if (options.metadata?.createdBy) {
    markdown += `Created by: ${options.metadata.createdBy}\n`;
  }
  markdown += `Powered by: SINTRA AI Multi-Agent System\n`;
  markdown += `---\n\n`;

  // Sections
  options.sections.forEach((section) => {
    markdown += `## ${section.title}\n\n`;

    if (section.author) {
      markdown += `*By: ${section.author}*\n\n`;
    }

    markdown += `${section.content}\n\n`;
    markdown += `---\n\n`;
  });

  // Footer
  markdown += `\n---\n`;
  markdown += `*This document was generated by SINTRA AI Multi-Agent Collaboration System*\n`;

  if (options.metadata?.collaborationId) {
    markdown += `*Collaboration ID: ${options.metadata.collaborationId}*\n`;
  }

  return markdown;
}

/**
 * Generate Business Plan from Collaboration
 */
export async function generateBusinessPlan(
  taskDescription: string,
  agentMessages: Array<{ agentName: string; content: string }>,
  collaborationId: string
): Promise<Buffer> {
  const sections: DocumentSection[] = [];

  // Executive Summary
  const execSummaryAgents = agentMessages.filter(m =>
    m.agentName === 'Emmie' || m.agentName === 'Aura'
  );

  if (execSummaryAgents.length > 0) {
    sections.push({
      title: 'Executive Summary',
      content: execSummaryAgents.map(m => m.content).join('\n\n'),
      author: execSummaryAgents.map(m => m.agentName).join(', ')
    });
  }

  // Market Analysis
  const marketAgents = agentMessages.filter(m =>
    m.agentName === 'Dexter' || m.agentName === 'Emmie'
  );

  if (marketAgents.length > 0) {
    sections.push({
      title: 'Market Analysis',
      content: marketAgents.map(m => m.content).join('\n\n'),
      author: marketAgents.map(m => m.agentName).join(', ')
    });
  }

  // Financial Projections
  const financeAgents = agentMessages.filter(m =>
    m.agentName === 'Finn'
  );

  if (financeAgents.length > 0) {
    sections.push({
      title: 'Financial Projections',
      content: financeAgents.map(m => m.content).join('\n\n'),
      author: 'Finn'
    });
  }

  // Legal & Compliance
  const legalAgents = agentMessages.filter(m =>
    m.agentName === 'Lex'
  );

  if (legalAgents.length > 0) {
    sections.push({
      title: 'Legal & Compliance',
      content: legalAgents.map(m => m.content).join('\n\n'),
      author: 'Lex'
    });
  }

  // Implementation Plan
  const implementAgents = agentMessages.filter(m =>
    m.agentName === 'Aura' || m.agentName === 'Kai'
  );

  if (implementAgents.length > 0) {
    sections.push({
      title: 'Implementation Plan',
      content: implementAgents.map(m => m.content).join('\n\n'),
      author: implementAgents.map(m => m.agentName).join(', ')
    });
  }

  // All other insights
  const otherAgents = agentMessages.filter(m =>
    !['Emmie', 'Aura', 'Dexter', 'Finn', 'Lex', 'Kai'].includes(m.agentName)
  );

  if (otherAgents.length > 0) {
    sections.push({
      title: 'Additional Insights',
      content: otherAgents.map(m => m.content).join('\n\n'),
      author: otherAgents.map(m => m.agentName).join(', ')
    });
  }

  return generatePDFDocument({
    title: 'Business Plan',
    subtitle: taskDescription,
    sections,
    metadata: {
      createdBy: 'AI Multi-Agent Collaboration',
      collaborationId,
      date: new Date()
    }
  });
}

/**
 * Generate Marketing Strategy Document
 */
export async function generateMarketingStrategy(
  taskDescription: string,
  agentMessages: Array<{ agentName: string; content: string }>,
  collaborationId: string
): Promise<Buffer> {
  const sections: DocumentSection[] = [
    {
      title: 'Strategy Overview',
      content: agentMessages
        .filter(m => m.agentName === 'Emmie')
        .map(m => m.content)
        .join('\n\n') || 'Strategy overview to be determined.',
      author: 'Emmie'
    },
    {
      title: 'Target Audience & Market Analysis',
      content: agentMessages
        .filter(m => m.agentName === 'Dexter')
        .map(m => m.content)
        .join('\n\n') || 'Market analysis to be conducted.',
      author: 'Dexter'
    },
    {
      title: 'Campaign Planning',
      content: agentMessages
        .filter(m => m.agentName === 'Aura')
        .map(m => m.content)
        .join('\n\n') || 'Campaign planning in progress.',
      author: 'Aura'
    },
    {
      title: 'Budget & ROI Projections',
      content: agentMessages
        .filter(m => m.agentName === 'Finn')
        .map(m => m.content)
        .join('\n\n') || 'Financial projections to be calculated.',
      author: 'Finn'
    },
    {
      title: 'All Agent Contributions',
      content: agentMessages.map(m => `**${m.agentName}:**\n${m.content}`).join('\n\n'),
      author: 'All Agents'
    }
  ];

  return generatePDFDocument({
    title: 'Marketing Strategy',
    subtitle: taskDescription,
    sections,
    metadata: {
      createdBy: 'AI Multi-Agent Collaboration',
      collaborationId,
      date: new Date()
    }
  });
}

/**
 * Generate Technical Documentation
 */
export async function generateTechnicalDoc(
  taskDescription: string,
  agentMessages: Array<{ agentName: string; content: string }>,
  collaborationId: string
): Promise<Buffer> {
  const sections: DocumentSection[] = [
    {
      title: 'Technical Overview',
      content: agentMessages
        .filter(m => m.agentName === 'Kai')
        .map(m => m.content)
        .join('\n\n') || 'Technical overview to be provided.',
      author: 'Kai'
    },
    {
      title: 'Architecture & Design',
      content: agentMessages
        .filter(m => m.agentName === 'Aura' || m.agentName === 'Kai')
        .map(m => m.content)
        .join('\n\n') || 'Architecture details to be specified.',
      author: 'Kai, Aura'
    },
    {
      title: 'Implementation Details',
      content: agentMessages
        .filter(m => m.agentName !== 'Kai' && m.agentName !== 'Aura')
        .map(m => `**${m.agentName}:**\n${m.content}`)
        .join('\n\n') || 'Implementation details to be documented.',
      author: 'All Agents'
    }
  ];

  return generatePDFDocument({
    title: 'Technical Documentation',
    subtitle: taskDescription,
    sections,
    metadata: {
      createdBy: 'AI Multi-Agent Collaboration',
      collaborationId,
      date: new Date()
    }
  });
}
