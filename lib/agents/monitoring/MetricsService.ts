/**
 * PHASE 7: Agent Metrics & Monitoring Service
 * Prometheus-style metrics collection for all enterprise agents
 */

import { Redis } from 'ioredis';

// ============================================
// METRIC TYPES
// ============================================

export type MetricType = 'counter' | 'gauge' | 'histogram' | 'summary';

export interface MetricLabel {
  [key: string]: string;
}

export interface MetricValue {
  value: number;
  labels: MetricLabel;
  timestamp: number;
}

export interface HistogramBucket {
  le: number; // less than or equal
  count: number;
}

export interface HistogramValue {
  buckets: HistogramBucket[];
  sum: number;
  count: number;
  labels: MetricLabel;
  timestamp: number;
}

export interface MetricDefinition {
  name: string;
  type: MetricType;
  help: string;
  labels?: string[];
  buckets?: number[]; // For histograms
}

// ============================================
// PREDEFINED AGENT METRICS
// ============================================

export const AGENT_METRICS: MetricDefinition[] = [
  // Request metrics
  {
    name: 'agent_requests_total',
    type: 'counter',
    help: 'Total number of requests to agents',
    labels: ['agent_id', 'status', 'workspace_id'],
  },
  {
    name: 'agent_request_duration_seconds',
    type: 'histogram',
    help: 'Request duration in seconds',
    labels: ['agent_id', 'tool'],
    buckets: [0.1, 0.25, 0.5, 1, 2.5, 5, 10, 30, 60],
  },
  {
    name: 'agent_errors_total',
    type: 'counter',
    help: 'Total number of agent errors',
    labels: ['agent_id', 'error_type', 'workspace_id'],
  },

  // Tool execution metrics
  {
    name: 'agent_tool_executions_total',
    type: 'counter',
    help: 'Total number of tool executions',
    labels: ['agent_id', 'tool_name', 'status'],
  },
  {
    name: 'agent_tool_execution_duration_seconds',
    type: 'histogram',
    help: 'Tool execution duration in seconds',
    labels: ['agent_id', 'tool_name'],
    buckets: [0.05, 0.1, 0.25, 0.5, 1, 2.5, 5, 10],
  },

  // OpenAI/LLM metrics
  {
    name: 'llm_tokens_total',
    type: 'counter',
    help: 'Total tokens used',
    labels: ['agent_id', 'model', 'token_type'], // token_type: prompt, completion
  },
  {
    name: 'llm_requests_total',
    type: 'counter',
    help: 'Total LLM API requests',
    labels: ['agent_id', 'model', 'status'],
  },
  {
    name: 'llm_request_duration_seconds',
    type: 'histogram',
    help: 'LLM request duration in seconds',
    labels: ['agent_id', 'model'],
    buckets: [0.5, 1, 2, 5, 10, 20, 30, 60],
  },

  // Dexter-specific metrics
  {
    name: 'dexter_reports_generated_total',
    type: 'counter',
    help: 'Total reports generated by Dexter',
    labels: ['report_type', 'workspace_id'],
  },
  {
    name: 'dexter_data_queries_total',
    type: 'counter',
    help: 'Total data queries executed by Dexter',
    labels: ['query_type', 'status'],
  },
  {
    name: 'dexter_forecast_accuracy',
    type: 'gauge',
    help: 'Forecast accuracy percentage',
    labels: ['forecast_type', 'workspace_id'],
  },

  // Cassie-specific metrics
  {
    name: 'cassie_tickets_handled_total',
    type: 'counter',
    help: 'Total tickets handled by Cassie',
    labels: ['resolution_type', 'workspace_id'],
  },
  {
    name: 'cassie_kb_searches_total',
    type: 'counter',
    help: 'Total knowledge base searches',
    labels: ['search_type', 'workspace_id'], // search_type: semantic, keyword
  },
  {
    name: 'cassie_response_satisfaction',
    type: 'gauge',
    help: 'Customer satisfaction score (0-100)',
    labels: ['workspace_id'],
  },
  {
    name: 'cassie_escalations_total',
    type: 'counter',
    help: 'Total escalations to human agents',
    labels: ['reason', 'workspace_id'],
  },

  // Aura-specific metrics
  {
    name: 'aura_workflows_executed_total',
    type: 'counter',
    help: 'Total workflows executed',
    labels: ['workflow_id', 'status', 'workspace_id'],
  },
  {
    name: 'aura_workflow_duration_seconds',
    type: 'histogram',
    help: 'Workflow execution duration in seconds',
    labels: ['workflow_id'],
    buckets: [1, 5, 10, 30, 60, 120, 300, 600],
  },
  {
    name: 'aura_scheduled_tasks_total',
    type: 'counter',
    help: 'Total scheduled tasks processed',
    labels: ['task_type', 'status'],
  },
  {
    name: 'aura_active_workflows',
    type: 'gauge',
    help: 'Number of currently active workflows',
    labels: ['workspace_id'],
  },

  // System metrics
  {
    name: 'agent_memory_usage_bytes',
    type: 'gauge',
    help: 'Agent memory usage in bytes',
    labels: ['agent_id'],
  },
  {
    name: 'agent_active_sessions',
    type: 'gauge',
    help: 'Number of active agent sessions',
    labels: ['agent_id'],
  },
];

// ============================================
// METRICS SERVICE
// ============================================

export class MetricsService {
  private redis: Redis | null = null;
  private metrics: Map<string, MetricDefinition> = new Map();
  private counters: Map<string, Map<string, number>> = new Map();
  private gauges: Map<string, Map<string, number>> = new Map();
  private histograms: Map<string, Map<string, HistogramValue>> = new Map();
  private readonly METRICS_PREFIX = 'agent:metrics:';
  private readonly METRICS_TTL = 86400; // 24 hours

  constructor() {
    // Initialize metric definitions
    for (const metric of AGENT_METRICS) {
      this.metrics.set(metric.name, metric);

      switch (metric.type) {
        case 'counter':
          this.counters.set(metric.name, new Map());
          break;
        case 'gauge':
          this.gauges.set(metric.name, new Map());
          break;
        case 'histogram':
          this.histograms.set(metric.name, new Map());
          break;
      }
    }
  }

  /**
   * Initialize with Redis for persistence
   */
  public async initialize(redisUrl?: string): Promise<void> {
    try {
      this.redis = new Redis(redisUrl || process.env.REDIS_URL || 'redis://localhost:6379');
      console.log('[METRICS] Connected to Redis for metrics persistence');

      // Load existing metrics from Redis
      await this.loadMetricsFromRedis();
    } catch (error) {
      console.warn('[METRICS] Redis not available, using in-memory only:', error);
      this.redis = null;
    }
  }

  /**
   * Generate label key from labels object
   */
  private labelKey(labels: MetricLabel): string {
    const sortedKeys = Object.keys(labels).sort();
    return sortedKeys.map(k => `${k}="${labels[k]}"`).join(',');
  }

  // ============================================
  // COUNTER OPERATIONS
  // ============================================

  /**
   * Increment a counter
   */
  public async inc(name: string, labels: MetricLabel = {}, value: number = 1): Promise<void> {
    const metric = this.metrics.get(name);
    if (!metric || metric.type !== 'counter') {
      console.warn(`[METRICS] Unknown counter: ${name}`);
      return;
    }

    const key = this.labelKey(labels);
    const counterMap = this.counters.get(name)!;
    const current = counterMap.get(key) || 0;
    counterMap.set(key, current + value);

    // Persist to Redis
    if (this.redis) {
      await this.redis.hincrby(`${this.METRICS_PREFIX}counter:${name}`, key, value);
    }
  }

  /**
   * Get counter value
   */
  public getCounter(name: string, labels: MetricLabel = {}): number {
    const counterMap = this.counters.get(name);
    if (!counterMap) return 0;
    return counterMap.get(this.labelKey(labels)) || 0;
  }

  // ============================================
  // GAUGE OPERATIONS
  // ============================================

  /**
   * Set a gauge value
   */
  public async set(name: string, value: number, labels: MetricLabel = {}): Promise<void> {
    const metric = this.metrics.get(name);
    if (!metric || metric.type !== 'gauge') {
      console.warn(`[METRICS] Unknown gauge: ${name}`);
      return;
    }

    const key = this.labelKey(labels);
    const gaugeMap = this.gauges.get(name)!;
    gaugeMap.set(key, value);

    // Persist to Redis
    if (this.redis) {
      await this.redis.hset(`${this.METRICS_PREFIX}gauge:${name}`, key, value.toString());
    }
  }

  /**
   * Increment a gauge
   */
  public async incGauge(name: string, labels: MetricLabel = {}, value: number = 1): Promise<void> {
    const gaugeMap = this.gauges.get(name);
    if (!gaugeMap) return;

    const key = this.labelKey(labels);
    const current = gaugeMap.get(key) || 0;
    await this.set(name, current + value, labels);
  }

  /**
   * Decrement a gauge
   */
  public async decGauge(name: string, labels: MetricLabel = {}, value: number = 1): Promise<void> {
    await this.incGauge(name, labels, -value);
  }

  /**
   * Get gauge value
   */
  public getGauge(name: string, labels: MetricLabel = {}): number {
    const gaugeMap = this.gauges.get(name);
    if (!gaugeMap) return 0;
    return gaugeMap.get(this.labelKey(labels)) || 0;
  }

  // ============================================
  // HISTOGRAM OPERATIONS
  // ============================================

  /**
   * Observe a histogram value
   */
  public async observe(name: string, value: number, labels: MetricLabel = {}): Promise<void> {
    const metric = this.metrics.get(name);
    if (!metric || metric.type !== 'histogram') {
      console.warn(`[METRICS] Unknown histogram: ${name}`);
      return;
    }

    const key = this.labelKey(labels);
    const histogramMap = this.histograms.get(name)!;

    let histogram = histogramMap.get(key);
    if (!histogram) {
      histogram = {
        buckets: (metric.buckets || [0.1, 0.5, 1, 5, 10]).map(le => ({ le, count: 0 })),
        sum: 0,
        count: 0,
        labels,
        timestamp: Date.now(),
      };
      histogramMap.set(key, histogram);
    }

    // Update buckets
    for (const bucket of histogram.buckets) {
      if (value <= bucket.le) {
        bucket.count++;
      }
    }
    histogram.sum += value;
    histogram.count++;
    histogram.timestamp = Date.now();

    // Persist to Redis
    if (this.redis) {
      await this.redis.hset(
        `${this.METRICS_PREFIX}histogram:${name}`,
        key,
        JSON.stringify(histogram)
      );
    }
  }

  /**
   * Get histogram data
   */
  public getHistogram(name: string, labels: MetricLabel = {}): HistogramValue | null {
    const histogramMap = this.histograms.get(name);
    if (!histogramMap) return null;
    return histogramMap.get(this.labelKey(labels)) || null;
  }

  // ============================================
  // TIMING HELPERS
  // ============================================

  /**
   * Time a function execution and record to histogram
   */
  public async time<T>(
    name: string,
    labels: MetricLabel,
    fn: () => Promise<T>
  ): Promise<T> {
    const start = performance.now();
    try {
      return await fn();
    } finally {
      const duration = (performance.now() - start) / 1000; // Convert to seconds
      await this.observe(name, duration, labels);
    }
  }

  /**
   * Create a timer that can be stopped
   */
  public startTimer(name: string, labels: MetricLabel = {}): () => Promise<number> {
    const start = performance.now();
    return async () => {
      const duration = (performance.now() - start) / 1000;
      await this.observe(name, duration, labels);
      return duration;
    };
  }

  // ============================================
  // AGENT-SPECIFIC HELPERS
  // ============================================

  /**
   * Record an agent request
   */
  public async recordAgentRequest(
    agentId: string,
    status: 'success' | 'error',
    workspaceId: string,
    durationSeconds?: number
  ): Promise<void> {
    await this.inc('agent_requests_total', { agent_id: agentId, status, workspace_id: workspaceId });

    if (durationSeconds !== undefined) {
      await this.observe('agent_request_duration_seconds', durationSeconds, { agent_id: agentId, tool: 'chat' });
    }

    if (status === 'error') {
      await this.inc('agent_errors_total', { agent_id: agentId, error_type: 'request', workspace_id: workspaceId });
    }
  }

  /**
   * Record a tool execution
   */
  public async recordToolExecution(
    agentId: string,
    toolName: string,
    status: 'success' | 'error',
    durationSeconds: number
  ): Promise<void> {
    await this.inc('agent_tool_executions_total', { agent_id: agentId, tool_name: toolName, status });
    await this.observe('agent_tool_execution_duration_seconds', durationSeconds, { agent_id: agentId, tool_name: toolName });
  }

  /**
   * Record LLM usage
   */
  public async recordLLMUsage(
    agentId: string,
    model: string,
    promptTokens: number,
    completionTokens: number,
    durationSeconds: number,
    status: 'success' | 'error' = 'success'
  ): Promise<void> {
    await this.inc('llm_tokens_total', { agent_id: agentId, model, token_type: 'prompt' }, promptTokens);
    await this.inc('llm_tokens_total', { agent_id: agentId, model, token_type: 'completion' }, completionTokens);
    await this.inc('llm_requests_total', { agent_id: agentId, model, status });
    await this.observe('llm_request_duration_seconds', durationSeconds, { agent_id: agentId, model });
  }

  /**
   * Record Dexter report generation
   */
  public async recordDexterReport(reportType: string, workspaceId: string): Promise<void> {
    await this.inc('dexter_reports_generated_total', { report_type: reportType, workspace_id: workspaceId });
  }

  /**
   * Record Cassie ticket handling
   */
  public async recordCassieTicket(resolutionType: string, workspaceId: string): Promise<void> {
    await this.inc('cassie_tickets_handled_total', { resolution_type: resolutionType, workspace_id: workspaceId });
  }

  /**
   * Record Aura workflow execution
   */
  public async recordAuraWorkflow(
    workflowId: string,
    status: 'success' | 'error' | 'cancelled',
    workspaceId: string,
    durationSeconds?: number
  ): Promise<void> {
    await this.inc('aura_workflows_executed_total', { workflow_id: workflowId, status, workspace_id: workspaceId });

    if (durationSeconds !== undefined) {
      await this.observe('aura_workflow_duration_seconds', durationSeconds, { workflow_id: workflowId });
    }
  }

  // ============================================
  // EXPORT & PERSISTENCE
  // ============================================

  /**
   * Export metrics in Prometheus format
   */
  public exportPrometheus(): string {
    const lines: string[] = [];

    // Export counters
    for (const [name, metric] of this.metrics) {
      if (metric.type !== 'counter') continue;

      lines.push(`# HELP ${name} ${metric.help}`);
      lines.push(`# TYPE ${name} counter`);

      const counterMap = this.counters.get(name);
      if (counterMap) {
        for (const [labelKey, value] of counterMap) {
          const labelStr = labelKey ? `{${labelKey}}` : '';
          lines.push(`${name}${labelStr} ${value}`);
        }
      }
      lines.push('');
    }

    // Export gauges
    for (const [name, metric] of this.metrics) {
      if (metric.type !== 'gauge') continue;

      lines.push(`# HELP ${name} ${metric.help}`);
      lines.push(`# TYPE ${name} gauge`);

      const gaugeMap = this.gauges.get(name);
      if (gaugeMap) {
        for (const [labelKey, value] of gaugeMap) {
          const labelStr = labelKey ? `{${labelKey}}` : '';
          lines.push(`${name}${labelStr} ${value}`);
        }
      }
      lines.push('');
    }

    // Export histograms
    for (const [name, metric] of this.metrics) {
      if (metric.type !== 'histogram') continue;

      lines.push(`# HELP ${name} ${metric.help}`);
      lines.push(`# TYPE ${name} histogram`);

      const histogramMap = this.histograms.get(name);
      if (histogramMap) {
        for (const [labelKey, histogram] of histogramMap) {
          const baseLabels = labelKey ? `${labelKey},` : '';

          for (const bucket of histogram.buckets) {
            lines.push(`${name}_bucket{${baseLabels}le="${bucket.le}"} ${bucket.count}`);
          }
          lines.push(`${name}_bucket{${baseLabels}le="+Inf"} ${histogram.count}`);
          lines.push(`${name}_sum{${labelKey || ''}} ${histogram.sum}`);
          lines.push(`${name}_count{${labelKey || ''}} ${histogram.count}`);
        }
      }
      lines.push('');
    }

    return lines.join('\n');
  }

  /**
   * Export metrics as JSON
   */
  public exportJSON(): Record<string, unknown> {
    const result: Record<string, unknown> = {
      timestamp: new Date().toISOString(),
      counters: {},
      gauges: {},
      histograms: {},
    };

    // Export counters
    for (const [name, counterMap] of this.counters) {
      (result.counters as Record<string, unknown>)[name] = Object.fromEntries(counterMap);
    }

    // Export gauges
    for (const [name, gaugeMap] of this.gauges) {
      (result.gauges as Record<string, unknown>)[name] = Object.fromEntries(gaugeMap);
    }

    // Export histograms
    for (const [name, histogramMap] of this.histograms) {
      (result.histograms as Record<string, unknown>)[name] = Object.fromEntries(histogramMap);
    }

    return result;
  }

  /**
   * Load metrics from Redis
   */
  private async loadMetricsFromRedis(): Promise<void> {
    if (!this.redis) return;

    try {
      // Load counters
      for (const name of this.counters.keys()) {
        const data = await this.redis.hgetall(`${this.METRICS_PREFIX}counter:${name}`);
        const counterMap = this.counters.get(name)!;
        for (const [key, value] of Object.entries(data)) {
          counterMap.set(key, parseInt(value, 10));
        }
      }

      // Load gauges
      for (const name of this.gauges.keys()) {
        const data = await this.redis.hgetall(`${this.METRICS_PREFIX}gauge:${name}`);
        const gaugeMap = this.gauges.get(name)!;
        for (const [key, value] of Object.entries(data)) {
          gaugeMap.set(key, parseFloat(value));
        }
      }

      // Load histograms
      for (const name of this.histograms.keys()) {
        const data = await this.redis.hgetall(`${this.METRICS_PREFIX}histogram:${name}`);
        const histogramMap = this.histograms.get(name)!;
        for (const [key, value] of Object.entries(data)) {
          histogramMap.set(key, JSON.parse(value));
        }
      }

      console.log('[METRICS] Loaded metrics from Redis');
    } catch (error) {
      console.error('[METRICS] Failed to load metrics from Redis:', error);
    }
  }

  /**
   * Reset all metrics
   */
  public async reset(): Promise<void> {
    for (const map of this.counters.values()) {
      map.clear();
    }
    for (const map of this.gauges.values()) {
      map.clear();
    }
    for (const map of this.histograms.values()) {
      map.clear();
    }

    if (this.redis) {
      const keys = await this.redis.keys(`${this.METRICS_PREFIX}*`);
      if (keys.length > 0) {
        await this.redis.del(...keys);
      }
    }
  }

  /**
   * Get metric definitions
   */
  public getMetricDefinitions(): MetricDefinition[] {
    return Array.from(this.metrics.values());
  }
}

// ============================================
// SINGLETON INSTANCE
// ============================================

let metricsInstance: MetricsService | null = null;

export function getMetricsService(): MetricsService {
  if (!metricsInstance) {
    metricsInstance = new MetricsService();
  }
  return metricsInstance;
}

export async function initializeMetrics(redisUrl?: string): Promise<MetricsService> {
  const service = getMetricsService();
  await service.initialize(redisUrl);
  return service;
}
